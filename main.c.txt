main.c

#include <stdio.h>    // 표준 입출력 함수 (printf, fgets, sprintf 등)
#include <stdlib.h>   // 표준 라이브러리 함수 (exit, atoi)
#include <unistd.h>   // POSIX 운영체제 API (fork, getpid, getppid, sleep, pipe, read, write, close)
#include <sys/wait.h> // waitpid 함수 사용을 위한 헤더
#include <stdbool.h>  // bool 타입 사용을 위한 헤더
#include <string.h>   // strlen, strcmp, strcspn 함수 사용을 위한 헤더
#include <errno.h>    // errno 사용을 위한 헤더
#include <sys/select.h> // select 함수 사용을 위한 헤더 (여러 파일 디스크립터 감시)
#include <sys/time.h> // select 함수의 timeval 구조체 사용을 위한 헤더
#include <sys/types.h> // select 함수의 fd_set 타입 사용을 위한 헤더

#define BUFFER_SIZE 256 // 파이프를 통해 데이터를 주고받을 버퍼 크기

void child1_process(int write_pipe_fd); // 자식 1 프로세스 함수 선언
void child2_process(int write_pipe_fd); // 자식 2 프로세스 함수 선언
void server_process(pid_t pid1, int read_pipe1_fd, pid_t pid2, int read_pipe2_fd); // 서버 프로세스 함수 선언

int main() {
    int pipe1_fd[2]; // 자식 1 -> 서버 파이프 (pipe1_fd[0]: 읽기, pipe1_fd[1]: 쓰기)
    int pipe2_fd[2]; // 자식 2 -> 서버 파이프 (pipe2_fd[0]: 읽기, pipe2_fd[1]: 쓰기)
    pid_t pid1, pid2; // 자식 프로세스 ID 저장 변수

    printf("[메인] 프로그램 시작. PID: %d\n", getpid());

    // 첫 번째 파이프 생성 (자식 1 -> 서버)
    if (pipe(pipe1_fd) == -1) {
        perror("[메인] pipe1 생성 실패");
        exit(EXIT_FAILURE);
    }

    // 두 번째 파이프 생성 (자식 2 -> 서버)
    if (pipe(pipe2_fd) == -1) {
        perror("[메인] pipe2 생성 실패");
        // 첫 번째 파이프는 이미 생성되었으므로 닫아주는 것이 좋음
        close(pipe1_fd[0]);
        close(pipe1_fd[1]);
        exit(EXIT_FAILURE);
    }

    // --- 자식 1 프로세스 생성 ---
    pid1 = fork();
    if (pid1 == -1) {
        perror("[메인] 자식 1 fork 실패");
        close(pipe1_fd[0]); close(pipe1_fd[1]);
        close(pipe2_fd[0]); close(pipe2_fd[1]);
        exit(EXIT_FAILURE);
    } else if (pid1 == 0) {
        // 자식 1 프로세스 영역
        // 자식 1은 pipe1_fd[1] (쓰기)만 사용하고, pipe2_fd는 사용하지 않음
        close(pipe1_fd[0]); // pipe1 읽기 끝 닫기
        close(pipe2_fd[0]); // pipe2 읽기 끝 닫기
        close(pipe2_fd[1]); // pipe2 쓰기 끝 닫기
        child1_process(pipe1_fd[1]); // 자식 1의 작업을 수행하는 함수 호출
        // child1_process 함수 내에서 exit() 호출됨
    }

    // --- 자식 2 프로세스 생성 (부모 프로세스에서 다시 fork) ---
    pid2 = fork();
    if (pid2 == -1) {
        perror("[메인] 자식 2 fork 실패");
        // 이전에 생성된 자식 1이 있을 수 있으므로 waitpid로 정리 필요
        // 여기서는 간단히 모든 파이프 닫고 종료
        close(pipe1_fd[0]); close(pipe1_fd[1]);
        close(pipe2_fd[0]); close(pipe2_fd[1]);
        // 자식 1이 살아있다면 좀비 프로세스가 될 수 있으므로 waitpid(pid1, NULL, 0) 필요
        // 하지만 예제 단순화를 위해 생략
        exit(EXIT_FAILURE);
    } else if (pid2 == 0) {
        // 자식 2 프로세스 영역
        // 자식 2는 pipe2_fd[1] (쓰기)만 사용하고, pipe1_fd는 사용하지 않음
        close(pipe2_fd[0]); // pipe2 읽기 끝 닫기
        close(pipe1_fd[0]); // pipe1 읽기 끝 닫기
        close(pipe1_fd[1]); // pipe1 쓰기 끝 닫기
        child2_process(pipe2_fd[1]); // 자식 2의 작업을 수행하는 함수 호출
        // child2_process 함수 내에서 exit() 호출됨
    }

    // --- 서버 (부모) 프로세스 영역 ---
    // 부모는 pipe1_fd[0] (읽기)와 pipe2_fd[0] (읽기)만 사용
    close(pipe1_fd[1]); // pipe1 쓰기 끝 닫기
    close(pipe2_fd[1]); // pipe2 쓰기 끝 닫기

    server_process(pid1, pipe1_fd[0], pid2, pipe2_fd[0]); // 서버의 작업을 수행하는 함수 호출

    // main 함수는 server_process가 종료된 후 실행됨
    return 0; // 이 코드는 실행되지 않음 (server_process에서 exit 호출)
}

// --- 자식 1 프로세스 함수 정의 ---
void child1_process(int write_pipe_fd) {
    printf("[자식1] 자식 프로세스 1 시작. PID: %d, 부모 PID: %d\n", getpid(), getppid());
    char num_str[BUFFER_SIZE];
    int current_num = -10;

    while (true) {
        sprintf(num_str, "%d", current_num); // 숫자를 문자열로 변환

        // 파이프에 데이터 쓰기
        if (write(write_pipe_fd, num_str, strlen(num_str) + 1) == -1) {
            perror("[자식1] 파이프 쓰기 오류");
            break; // 오류 발생 시 루프 탈출
        }
        printf("[자식1] '%s'를 서버에게 전달했습니다.\n", num_str);

        // 다음 숫자로 업데이트 (-10, -20, ..., -90, 그리고 다시 -10)
        current_num -= 10;
        if (current_num < -90) {
            current_num = -10; // -90 다음은 다시 -10
        }

        sleep(1); // 1초 대기
    }

    // 자식 프로세스 종료 전, 쓰기 파이프 끝을 닫습니다.
    close(write_pipe_fd);
    printf("[자식1] 자식 프로세스 1 종료.\n");
    exit(EXIT_SUCCESS);
}

// --- 자식 2 프로세스 함수 정의 ---
void child2_process(int write_pipe_fd) {
    printf("[자식2] 자식 프로세스 2 시작. PID: %d, 부모 PID: %d\n", getpid(), getppid());
    char input_buffer[BUFFER_SIZE];

    while (true) {
        printf("[자식2] 숫자를 입력하세요 ('q' 입력 시 종료): ");
        fflush(stdout); // 출력 버퍼 비우기

        // fgets를 사용하여 문자열(숫자) 입력받기
        if (fgets(input_buffer, BUFFER_SIZE, stdin) == NULL) {
            perror("[자식2] 입력 오류");
            break; // 오류 발생 시 루프 탈출
        }

        // 입력된 문자열의 마지막에 있는 개행 문자 제거
        input_buffer[strcspn(input_buffer, "\n")] = 0;

        // 'q' 또는 'Q' 입력 시 종료
        if (strcmp(input_buffer, "q") == 0 || strcmp(input_buffer, "Q") == 0) {
            printf("[자식2] 'q'가 입력되어 자식 프로세스를 종료합니다.\n");
            break; // 루프 탈출
        } else {
            // 부모에게 숫자 전달
            if (write(write_pipe_fd, input_buffer, strlen(input_buffer) + 1) == -1) {
                perror("[자식2] 파이프 쓰기 오류");
                break; // 오류 발생 시 루프 탈출
            }
            printf("[자식2] '%s'를 서버에게 전달했습니다.\n", input_buffer);
        }
    }

    // 자식 프로세스 종료 전, 쓰기 파이프 끝을 닫습니다.
    close(write_pipe_fd);
    printf("[자식2] 자식 프로세스 2 종료.\n");
    exit(EXIT_SUCCESS);
}

// --- 서버 (부모) 프로세스 함수 정의 ---
void server_process(pid_t pid1, int read_pipe1_fd, pid_t pid2, int read_pipe2_fd) {
    printf("[서버] 서버 프로세스 시작. PID: %d, 자식1 PID: %d, 자식2 PID: %d\n", getpid(), pid1, pid2);

    int counter = 0;
    long long total_sum = 0; // 누적 합계를 저장할 변수 (언더플로우 방지를 위해 long long 사용)
    char received_buffer[BUFFER_SIZE]; // 파이프에서 읽은 데이터를 저장할 버퍼
    int status; // 자식 프로세스의 종료 상태를 저장할 변수

    // 자식 프로세스들의 활성 상태를 추적하는 플래그
    bool child1_active = true;
    bool child2_active = true;

    // select()를 위한 변수들
    fd_set read_fds; // 읽을 파일 디스크립터 집합
    int max_fd = (read_pipe1_fd > read_pipe2_fd) ? read_pipe1_fd : read_pipe2_fd; // 가장 큰 파일 디스크립터 번호

    while (child1_active || child2_active) { // 두 자식 중 하나라도 활성화되어 있으면 루프 계속
        FD_ZERO(&read_fds); // 파일 디스크립터 집합 초기화

        // 각 파이프의 읽기 끝이 아직 유효하면 집합에 추가
        if (child1_active) {
            FD_SET(read_pipe1_fd, &read_fds);
        }
        if (child2_active) {
            FD_SET(read_pipe2_fd, &read_fds);
        }

        // select() 대기 시간 설정 (1초)
        struct timeval timeout;
        timeout.tv_sec = 1;
        timeout.tv_usec = 0;

        // select 호출: 파이프에 데이터가 있거나 타임아웃이 발생할 때까지 대기
        int ready_fds = select(max_fd + 1, &read_fds, NULL, NULL, &timeout);

        if (ready_fds == -1) {
            // select 오류 발생 (인터럽트 제외)
            if (errno == EINTR) { // 시그널에 의해 인터럽트된 경우
                continue; // 다시 루프 시작
            }
            perror("[서버] select 오류");
            break; // 심각한 오류 발생 시 루프 탈출
        } else if (ready_fds == 0) {
            // 타임아웃 발생 (데이터 없음)
            // 서버의 자체 연산만 수행
        } else {
            // 파이프에 데이터가 도착했거나, 파이프 끝이 닫혔음을 감지
            if (child1_active && FD_ISSET(read_pipe1_fd, &read_fds)) {
                ssize_t bytes_read = read(read_pipe1_fd, received_buffer, BUFFER_SIZE - 1);
                if (bytes_read > 0) {
                    received_buffer[bytes_read] = '\0'; // 널 종료 문자 추가
                    printf("[서버] 자식1로부터 받은 숫자: %s\n", received_buffer);
                    long long num = atoll(received_buffer); // long long으로 변환
                    total_sum += num; // 누적 합계 업데이트
                    printf("[서버] (변환된 숫자: %lld, 현재 누적 합: %lld)\n", num, total_sum);
                } else if (bytes_read == 0) {
                    // 자식 1이 파이프 쓰기 끝을 닫았음 (EOF)
                    printf("[서버] 자식1 파이프 닫힘 (EOF 감지).\n");
                    child1_active = false; // 자식 1 비활성으로 표시
                    close(read_pipe1_fd); // 읽기 파이프 끝 닫기
                } else { // bytes_read == -1
                    if (errno != EAGAIN && errno != EWOULDBLOCK) {
                        perror("[서버] 자식1 파이프 읽기 오류");
                        child1_active = false; // 오류 발생 시 비활성으로 표시
                        close(read_pipe1_fd);
                    }
                }
            }

            if (child2_active && FD_ISSET(read_pipe2_fd, &read_fds)) {
                ssize_t bytes_read = read(read_pipe2_fd, received_buffer, BUFFER_SIZE - 1);
                if (bytes_read > 0) {
                    received_buffer[bytes_read] = '\0'; // 널 종료 문자 추가
                    printf("[서버] 자식2로부터 받은 숫자: %s\n", received_buffer);
                    long long num = atoll(received_buffer); // long long으로 변환
                    total_sum += num; // 누적 합계 업데이트
                    printf("[서버] (변환된 숫자: %lld, 현재 누적 합: %lld)\n", num, total_sum);
                } else if (bytes_read == 0) {
                    // 자식 2가 파이프 쓰기 끝을 닫았음 (EOF)
                    printf("[서버] 자식2 파이프 닫힘 (EOF 감지).\n");
                    child2_active = false; // 자식 2 비활성으로 표시
                    close(read_pipe2_fd); // 읽기 파이프 끝 닫기
                } else { // bytes_read == -1
                    if (errno != EAGAIN && errno != EWOULDBLOCK) {
                        perror("[서버] 자식2 파이프 읽기 오류");
                        child2_active = false; // 오류 발생 시 비활성으로 표시
                        close(read_pipe2_fd);
                    }
                }
            }
        }

        // 서버의 자체 연산 (카운터 증가)
        printf("[서버] 현재 연산 값: %d\n", counter++);

        // 자식 프로세스 상태 확인 (좀비 프로세스 방지)
        // WNOHANG 옵션으로 블록되지 않고 상태 확인
        pid_t terminated_pid;
        while ((terminated_pid = waitpid(-1, &status, WNOHANG)) > 0) {
            if (terminated_pid == pid1) {
                printf("[서버] 자식1 (%d) 종료 감지.\n", pid1);
                child1_active = false;
            } else if (terminated_pid == pid2) {
                printf("[서버] 자식2 (%d) 종료 감지.\n", pid2);
                child2_active = false;
            }
        }
        // waitpid 오류 처리
        if (terminated_pid == -1 && errno != ECHILD) {
            perror("[서버] waitpid 오류");
        }

        // 두 자식 모두 종료되었으면 루프 종료 조건 검사
        if (!child1_active && !child2_active) {
            printf("[서버] 모든 자식 프로세스 종료됨. 서버 종료.\n");
            break;
        }
    }

    // 남아있는 파이프 읽기 끝을 모두 닫습니다.
    if (child1_active) close(read_pipe1_fd); // 혹시 루프 종료 전에 닫히지 않았을 경우
    if (child2_active) close(read_pipe2_fd); // 혹시 루프 종료 전에 닫히지 않았을 경우

    printf("[서버] 서버 프로세스 종료.\n");
    exit(EXIT_SUCCESS); // 서버 프로세스 정상 종료
}
